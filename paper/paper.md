---
title: "PyCAPGE: A Python Engine for Classic Adventure Game Education"
tags:
  - Python
  - Pygame
  - game-engine
  - software-education
  - object-oriented-programming
  - adventure-games
  - digital-preservation
  - open-source
authors:
  - name: Eduardo Garbayo
    orcid: 0009-0008-0347-833X
    affiliation: 1
affiliations:
  - name: Zainder.com, Spain
    index: 1
date: 2025-07-30
bibliography: paper.bib
---

# Summary

PyCAPGE (Python Classic Adventure Point-and-Click Game Engine) is an open-source engine built upon the Pygame library (providing an abstraction over SDL2) for building classic-style graphical adventure games in Python. It reimplements point-and-click adventure mechanics (navigable rooms with hotspots, inventory, dialogs, and puzzles) in a modern, data-driven architecture. All core systems (main loop, finite-state machine, resource management) are visible in the code rather than hidden behind an editor. For example, scene transitions and item interactions are scripted in Python (often via simple callback tables rather than a graphical GUI). This preserves the logic of classic games while making the internals explicit, so that students can inspect how scenes, objects, and interactions are implemented.

# Statement of need

Teaching object-oriented programming often suffers from an “abstraction gap” [@Kolling1999]. Basic tools (Scratch, Pygame Zero) simplify syntax but hide architecture, while professional engines (Unity, Godot) are so complex that they obscure core concepts. PyCAPGE fills this gap by providing a complete adventure game engine that remains small and readable. It implements the discrete gameplay of point-and-click adventures (modeled as finite-state machines [@Sicart2008]) using straightforward object-oriented code. For instance, a `Hotspot` class represents any interactive object and a `Scene` class represents a location. Abstract concepts become concrete: an `AnimatedHotspot` extends `Hotspot` with animation (illustrating inheritance), and verb commands map directly to callback functions. Each line of code produces visible results in the running game, making learning engaging.

Beyond pedagogy, PyCAPGE serves a critical role in digital preservation and software archaeology. By reimplementing the logic of 1990s engines in readable high-level code—rather than simply emulating binaries—it provides an accessible artifact for researchers studying the history of game development mechanics and engine architecture.

The design of PyCAPGE is informed by the author’s two decades of experience in engine development, including a C-based implementation in 1997 and a Java-based adventure system in 2001. Lessons learned from the complexity of those earlier iterations directly influenced the choice of Python and the simplified architecture presented here.

To support these educational needs, PyCAPGE is released under GPLv3 on GitHub and SourceForge [@PyCAPGE_GitHub; @PyCAPGE_SourceForge] with complete source code, documentation, and a playable demo archived on Zenodo [@PyCAPGE_Zenodo]. Its lightweight, well-documented design facilitates use in both education and research; instructors can run the demo scenes to illustrate concepts like event loops, collision detection, or inventory management with live examples. The modular codebase invites extensions (e.g. adding new verbs or localization) and signals community readiness for contributions. We anticipate that PyCAPGE will be adopted by educators and researchers interested in computing pedagogy, game-based learning, and digital preservation.

# State of the field

Existing tools for game-based learning lie at two extremes. Scratch or basic Pygame tutorials [@Sweigart2012] let novices animate sprites but provide no engine structure (no scene manager, no built-in item systems). Conversely, Unity and Godot [@Unity2023] offer full game frameworks, but their rich editors and autogenerated code introduce high overhead and obscure the program’s flow from beginners. Adventure-specific tools like Adventure Game Studio (AGS) let designers build games with visual editors and proprietary scripts, but they do not reveal implementation details. Likewise, systems such as ScummVM [@ScummVM2024] run classic titles on modern hardware, but their C++ codebases are meant for playing games, not for teaching. PyCAPGE differentiates itself by occupying the middle ground: it is implemented in standard Python (using SDL2/Pygame) under a GPLv3 license, and all game logic is defined in readable code. This transparency makes the link between design and implementation explicit and accessible to learners.

# Software design

PyCAPGE’s architecture is arranged in clear layers for education. Global configuration (Python modules and YAML files) defines constants (screen size, speeds) and data (scene identifiers, text, inventory items). The core engine layer (`classes.py`) provides fundamental classes like `Scene`, `Hotspot`, and `Character`, and implements systems such as collision detection (via pixel-masks) and pathfinding (grid-based A*). To support comparative analysis, the engine exposes configurable algorithms (e.g., allowing students to toggle between Euclidean and Manhattan distance heuristics) and variable text visualization styles (simulating classic LucasArts floating text versus Sierra portrait overlays). Furthermore, to optimize performance on educational hardware, the engine implements a ResourceManager with lazy loading and caching, ensuring assets are loaded into memory only when required by the active scene. A SceneManager loads scene definitions; the main program (`main.py`) initializes subsystems (audio, input, resource manager) and enters the main loop [@Gregory2018]. This loop is a finite-state machine: in an “Explore” state it handles character movement and interactions, whereas in a “Dialogue” state it blocks movement and advances conversation. This explicit state machine design teaches how to coordinate update and render steps across modes [@Gamma1994].

Gameplay logic is defined declaratively in Python. Each interactive object is created in code with its position, sprite, and a dictionary of actions. Keys are verb-object strings (e.g. `"USE_KEY_ON_DOOR"`) and values are Python lambda callbacks. When executed, these callbacks update the `GAME_STATE` dictionary, play sounds, or change inventory. This event-driven model demonstrates that functions are first-class: behaviors can be passed around and invoked at runtime. Students populate scenes by instantiating objects in code rather than using a visual editor, reinforcing the distinction between classes (templates) and instances. The game state (inventory, puzzle flags, etc.) is stored in Python dictionaries that can be saved to disk (JSON), illustrating persistence.

# AI usage disclosure

Generative AI tools were used to assist the author during the development of this project. These tools supported tasks such as translating the manuscript into English, improving clarity and academic style, debugging code, and answering programming-related questions during development.
All software design decisions, final implementations, and scientific claims were made by the author, who takes full responsibility for the correctness, originality, and integrity of both the software and the manuscript.




